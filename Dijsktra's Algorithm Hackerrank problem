//package dijkstrasShortestReachHACKERRANK;
import java.util.*;
import java.io.*;
class graph{
    private int n;
    private LinkedList<Integer> adj[];
    private int cost[][];
    graph(int n){
        this.n=n;
        adj=new LinkedList[n];
        cost=new int[n][n];
        for(int i=0;i<n;i++)
            adj[i]=new LinkedList<Integer>();
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                cost[i][j]=100000;
            }
        }
    }
    void addEdge(int s,int d,int c){
        adj[s].add(d);
        adj[d].add(s);
        cost[s][d]=Math.min(c,cost[s][d]);
        cost[d][s]=Math.min(c,cost[d][s]);
    }
    void shortestpath(int source){
        int dist[]=new int[n];
        TreeSet<Integer> set=new TreeSet<Integer>();
    //    boolean visited[]=new boolean[n];
        for(int i=0;i<n;i++){
            dist[i]=Integer.MAX_VALUE;
            set.add(i);
        }
        dist[source]=0;
        while(set.size()!=0){
            int minNode=minimum(set,dist);
            set.remove(minNode);
            if(set.size()==0)
                break;
            Iterator<Integer> itr=adj[minNode].iterator();
            while(itr.hasNext()){
                int next=itr.next();
                if(dist[minNode]+cost[minNode][next]<dist[next]){
                    dist[next]=dist[minNode]+cost[minNode][next];
                }
            }
        }
        for(int i=0;i<n;i++){
            if(i==source)
                continue;
            else{
                if(dist[i]==Integer.MAX_VALUE||dist[i]<0)
                    System.out.print(-1+" ");
                else
                    System.out.print(dist[i]+" ");
            }
        }
        System.out.println();
    }
    int minimum(TreeSet<Integer> set,int dist[]){
        int minNode=-1;
        int minDist=Integer.MAX_VALUE;
        Iterator<Integer> itr=set.iterator();
        while(itr.hasNext()){
            int next=itr.next();
            if(dist[next]<minDist){
                minDist=dist[next];
                minNode=next;
            }
        }
        if(minNode==-1)
        	return set.last();
        return minNode;
    }
}
class main{
    public static void main(String[] args) throws IOException{
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        int t=Integer.parseInt(br.readLine());
        while(t-- >0){
            String line[]=br.readLine().split(" ");
            int n=Integer.parseInt(line[0]);
            graph g=new graph(n);
            int m=Integer.parseInt(line[1]);
            for(int i=0;i<m;i++){
               String l[]=br.readLine().split(" ");
                int s=Integer.parseInt(l[0]);
                int d=Integer.parseInt(l[1]);
                int c=Integer.parseInt(l[2]);
                g.addEdge(s-1,d-1,c);
            }
            int s=Integer.parseInt(br.readLine());
            g.shortestpath(s-1);
    }
}
}
